/**
 * Copyright (c) 2008-2012 Ardor Labs, Inc.
 *
 * This file is part of Ardor3D.
 *
 * Ardor3D is free software: you can redistribute it and/or modify it under the
 * terms of its license which may be found in the accompanying LICENSE file or
 * at <http://www.ardor3d.com/LICENSE>.
 */
package com.ardor3d;

import com.ardor3d.image.Texture;
import com.ardor3d.image.util.awt.AWTImageLoader;
import com.ardor3d.math.Matrix3;
import com.ardor3d.math.Vector2;
import com.ardor3d.math.Vector3;
import com.ardor3d.renderer.Camera;
import com.ardor3d.renderer.Camera.ProjectionMode;
import com.ardor3d.renderer.Renderer;
import com.ardor3d.renderer.queue.RenderBucketType;
import com.ardor3d.renderer.state.BlendState;
import com.ardor3d.renderer.state.TextureState;
import com.ardor3d.scenegraph.Mesh;
import com.ardor3d.scenegraph.hint.TransparencyType;
import com.ardor3d.ui.text.BMText;
import com.ardor3d.util.TextureManager;
import com.ardor3d.util.geom.BufferUtils;
import java.awt.AlphaComposite;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.font.TextAttribute;
import java.awt.font.TextLayout;
import java.awt.image.BufferedImage;
import java.nio.FloatBuffer;
import java.text.AttributedString;

/**
 * Text spatial which uses textures generated by BMFont
 */
public class RasterTextLabel extends Mesh {

    /**
     * Underlying image used. Only set if this is a dynamic label
     */
    private BufferedImage textImage;

    /**
     * The clear colour used to clear the background of the image
     */
    private static final Color CLEAR_COLOR = new Color(255, 255, 255, 0);

    /**
     * The current color of the text
     */
    private final Color textColor;
    
    
    protected boolean _autoRotate = true;

    protected final Vector3 _look = new Vector3();
    protected final Vector3 _left = new Vector3();
    protected final Matrix3 _rot = new Matrix3();
    protected double _fontScale = 1.0;
    protected AutoFade _autoFade = AutoFade.FixedPixelSize;
    protected int _fixedPixelAlphaThresh = 14;
    protected float _screenSizeAlphaFalloff = 0.7f; // 0=instant, 1=half size
    protected final Vector2 _distanceAlphaRange = new Vector2(50, 75);

    public enum AutoScale {
        /**
         * No auto scaling
         */
        Off,

        /**
         * Maintain native point size of font regardless of distance from camera
         */
        FixedScreenSize,

        /**
         * Do not auto scale if font screen size is smaller than native point size, otherwise maintain native point
         * size.
         */
        CapScreenSize;
    }

    protected AutoScale _autoScale = AutoScale.FixedScreenSize;

    /**
     * @see BMText#setAutoFadeDistanceRange(double, double)
     * @see BMText#setAutoFadeFixedPixelSize(int)
     * @see BMText#setAutoFadeFalloff(float)
     */
    public enum AutoFade {
        /**
         * No auto fade.
         */
        Off,

        /**
         * Fade based on a fixed distance between text and camera.
         */
        DistanceRange,

        /**
         * Fade when screen size is less than fixed pixel size.
         */
        FixedPixelSize,

        /**
         * Fade when screen size is less than native size. Equivalent to FixedPixelSize +
         * setAutoFadeFixedPixelSize(font.getSize()).
         */
        CapScreenSize;
    }

    @SuppressWarnings("this-escape")
    public RasterTextLabel(AttributedString label,
            Color col,
            double x,
            double y,
            double z) {
        textColor = col;
        if (label != null) {

            // create a disposable 1x1 image so that we can fetch the font
            // metrics associated with the font and text label. This will allow
            // us to determine the real image size. This is kludgy, but I can't
            // think of a better way of doing it!
            BufferedImage tmp_img
                    = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB);

            Graphics2D graphics = (Graphics2D) tmp_img.getGraphics();

            int width;
            int height;

            TextLayout tl = new TextLayout(label.getIterator(), graphics.getFontRenderContext());

            width = (int) tl.getAdvance() + 1;
            float ascent = tl.getAscent();
            height = (int) (ascent + tl.getDescent()) + 1;

            graphics.dispose();
            tmp_img.flush();

            textImage = new BufferedImage(width,
                    height,
                    BufferedImage.TYPE_INT_ARGB);

            graphics = (Graphics2D) textImage.getGraphics();

            renderImage(graphics, label, width, height, ascent);

            graphics.dispose();

            init();

            final TextureState ts = new TextureState();
            ts.setTexture(TextureManager.loadFromImage(AWTImageLoader.makeArdor3dImage(textImage, false), Texture.MinificationFilter.Trilinear));
            setRenderState(ts);

            BlendState blend = new BlendState();
            blend.setBlendEnabled(true);
            setRenderState(blend);

            getSceneHints().setRenderBucketType(RenderBucketType.Transparent);
            getSceneHints().setTransparencyType(TransparencyType.TwoPass);

            setTranslation(x, y, z);
        }
    }

    /**
     * Convenience method to render the image given the font information. When
     * this method exits, it will have changed the global imageWidth and
     * imageHeight variables to the given width and height values.
     *
     * @param graphics The graphics context for textImage
     * @param label The string to render
     * @param width The width of the image drawn to
     * @param height The height of the image drawn to
     * @param ascent The ascent of the font in use
     */
    private void renderImage(Graphics2D g,
            AttributedString as,
            int width,
            int height,
            float ascent) {
        g.setComposite(AlphaComposite.Src);
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); // Anti-alias!

        as.addAttribute(TextAttribute.FOREGROUND, textColor);
        as.addAttribute(TextAttribute.BACKGROUND, CLEAR_COLOR);

        g.setColor(CLEAR_COLOR);
        g.fillRect(0, 0, width, height);

        g.drawString(as.getIterator(), 0, ascent);
    }

    private void init() {

        FloatBuffer vertices = BufferUtils.createVector3Buffer(6);
        FloatBuffer texCrds = BufferUtils.createVector2Buffer(6);
        getMeshData().setVertexBuffer(vertices);
        getMeshData().setTextureBuffer(texCrds, 0);

        float t, b, l, r;

        // -- vertices -----------------
        l = 0;
        t = 0;
        r = textImage.getWidth();
        b = textImage.getHeight();

        vertices.put(l).put(0).put(t); // left top
        vertices.put(l).put(0).put(b); // left bottom
        vertices.put(r).put(0).put(t); // right top
        vertices.put(r).put(0).put(t); // right top
        vertices.put(l).put(0).put(b); // left bottom
        vertices.put(r).put(0).put(b); // right bottom

        // -- tex coords ----------------
        l = 0.01f;
        t = 0.01f;
        r = 0.99f;
        b = 0.99f;

        texCrds.put(l).put(t); // left top
        texCrds.put(l).put(b); // left bottom
        texCrds.put(r).put(t); // right top
        texCrds.put(r).put(t); // right top
        texCrds.put(l).put(b); // left bottom
        texCrds.put(r).put(b); // right bottom
    }

    @Override
    public synchronized void draw(final Renderer r) {
        final Camera cam = Camera.getCurrentCamera();

        if (!(_autoScale == AutoScale.Off && _autoFade == AutoFade.Off)) {
            updateScaleAndAlpha(cam, r);
        }
        correctTransform(cam);

        super.draw(r);
    }

    /**
     *
     * @param cam
     */
    public void correctTransform(final Camera cam) {
        updateWorldTransform(false);

        if (_autoRotate) {
            // Billboard rotation
            _look.set(cam.getDirection());
            _left.set(cam.getLeft()).negateLocal();
            _rot.fromAxes(_left, _look, cam.getUp());
            _worldTransform.setRotation(_rot);
        }
        _worldTransform.setScale(_localTransform.getScale());
    }


    /**
     * Update the text's scale
     * 
     * @param cam
     * @param r
     */
    public void updateScaleAndAlpha(final Camera cam, final Renderer r) {
        // get our depth distance
        _look.set(cam.getLocation());
        _look.negateLocal().addLocal(_worldTransform.getTranslation());

        final double zDepth = cam.getDirection().dot(_look);
        if (zDepth > cam.getFrustumFar() || zDepth < cam.getFrustumNear()) {
            // it is out of the picture.
            return;
        }

        // calculate the height in world units of the screen at that depth
        final double heightAtZ;
        if (cam.getProjectionMode() == ProjectionMode.Parallel) {
            heightAtZ = cam.getFrustumTop();
        } else {
            heightAtZ = zDepth * cam.getFrustumTop() / cam.getFrustumNear();
        }

        // determine a unit/pixel ratio using height
        final double screenHeight = cam.getHeight();
        final double pixelRatio = heightAtZ / screenHeight;

        // scale value used to maintain uniform size in screen coords.
        // when depthScale > unitFont, text is far away
        final double depthScale = 2 * pixelRatio;

        if (_autoScale != AutoScale.Off) {
            double finalScale = depthScale;
            finalScale *= _fontScale;
            setScale(finalScale, finalScale, -finalScale);
        }
    }
}
